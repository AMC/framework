  versioning through .htaccess?
    no through api.php
      pass as query string?
    isn't there a version option in http headers?
  
http://lcsd05.cs.tamu.edu/slides/keynote.pdf
http://wiki.netbeans.org/API_Design

http://blog.programmableweb.com/
http://blogs.msdn.com/b/mssblog/archive/2006/05/30/611159.aspx
http://www.codewalkers.com/c/a/Miscellaneous/Create-Your-Own-Custom-API/


https://www.youtube.com/watch?v=heh4OeB9A-c

https://www.youtube.com/watch?v=ITmcAGvfcJI



How to Design Great APIs - Parse Developer Day 2013
  https://www.youtube.com/watch?v=qCdpTji8nxo
  API
    the surface other developers use to put your code in their software
  easy to use
  snap into your code
    like legos
  
  Laziness
    the most powerful emotion for a developer
  
  1. Intuitive
      Consistent
  2. Documented
      Similar to a data structure
      retrieve in O(1)
      what do you docs answer?
        what does X do?
          answer with reference docs
          sim to dictionary - boring
          exhaustive
          javadoc, jsdoc
          REST API examples for cut & paste
        how do I do x?
          tutorials / guides
          not boring
        what can I do in 2 minutes?
          quickstart
          as simple as possible
  3. Opinionated
      consistent among team and developers using your product
  similar things should look similar

  ugly things should look ugly
      
  simple questions should be simple to answer


** Beautiful REST & JSON APIs
  https://www.youtube.com/watch?v=mZ8_QgJ5mbs
  
  Why REST?
    scalable
      any language can leverage
    general
      many use cases
    independent
      independence from implementation
      communicate through rest regardless of language
    latency / caching
    security
      authentication header
    encapsulation
    
  Why JSON?
    ubiquity
    simplicity
    readability 
    scalability
    flexibility
    
  Rest is hard
    no standard / RFC
  
  Common conventions
    resources
      noun, not verb
      plural endpoints
      coarse grained
      Collection Resource
        multiple instances
      Instance Resource
        single properties of a single instance
    behavior (per HTTP specs)
      GET
        read
      PUT
        idempotent (can be done one or many times)
        create (if ID is known)
        update (full replacement only, not partial)
      POST
        not idempotent
        create (on a parent resource, server generates ID)
          returns 201 with location header in response
        update (partial update, using ID)
          returns 200 OK
      DELETE
        delete
      HEAD
        metadata
    media type
      format specification and parsing rules
      tells server what to use with accept header
      tells the client what is sent with content-type header
      can create own media types
        use for versioning
        
  show same content whether API client or browser
  versioning
    embed in url
      more common
    OR
    media-type
      more correct
      
  ** use camelCase ***
  
  use the Timestamp standard ISO 8601
    use UTC
  
  distributed hypermedia
    every resource is accessible
    resources can contact other resources
    href are super important
    always return fully qualified url
      {"href" : "fully qualified url"}
      also return for parent
      return for child?
      
  response body
    return the representation in the response
    (server may change something, return so client has most recent/accurate version)
    allow query parameter to override (for large files)
    
    include offset and limit in response with href to next, prev, first, last
    
  many to many
    use resource to map this resource
      store information about the link between resources
      sim to join table
      
  errors
    be as descriptive as possible
    as much information as possible
    developers are your customers
    
    give link for moreInfo: api/.../error
    html code AND application error code
    what property caused the problem
    message for end user
    developerMessage for developer
    
  security
    avoid sessions
    REST is stateless
    authorized based on resource content, not url!
    use existing auth protocol: OAuth1.0a/2, Basic over SSL
      OAuth1.0a is safest
    use API keys instead of username/password
    401 is unauthenticated
    403 is permission denied
    
  caching
    etag - version of document
    
    
SOAP vs REST
  https://www.youtube.com/watch?v=v3OMEAU_4HI
  
  Simple Object Access Protocol
    evolution of XML over RPC
    exposes operations that expose logic
    loose coupling for diverse systems
      distributed computing
    standard error messaging
    aligns with enterprise application needs and goals
    supports other transport protocols beyond HTTP
    ACID compliant
    Reliable messaging
    Strong typing
    uses HTTP POST
    stateful
    uses schemas
  REST
    exposes resources that represent data
    point-to-point
    uses HTTP Verbs
    stateless
    multiple-data formats
    no schema, and no strong typing
    
  REST Pro
    consumed by any client
    lightweight, no XML parsing
    safe
    easy to learn
    
  SOAP Pro
  
How to Design a Good API and Why it Matters
  https://www.youtube.com/watch?v=heh4OeB9A-c
  
  Customers invest in API
    buying, writing, learning
      don't want to learn a new one
    expensive to stop using API
    successful APIs capture customers
  Public APIs are forever
  Without versioning, can inhibit ability to move forward  
    
  Good programming is Modular
    APIs!
    good APIs are reused
  
  APIs are nice units, good practices
  
  Good API characteristics
    easy to learn
    easy to use, even without documentation
      hard to mis-use
    easy to read and maintain code that uses it
    sufficiently powerful to satisfy requirements
      just powerful enough
    easy to evolve
      satisfy new needs (future requirements)
    appropriate to audience
    
    
  Gather requirements
    healthy degree of skepticism
    extra true requirements
    takes to form of use-cases
    easier to build a more general solution
  
  Short Spec, agile is better
    easier to modify
    flesh it out as you go
    
  ** recoverable requests? **
  
  Aim to displease everyone equally
    You can't please everyone
    
  If it's hard to name, it's a bad
  
  
  